<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒêi·ªÅu khi·ªÉn ESP32-S3</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #1976D2;
        }
        
        .info-box p {
            margin: 5px 0;
            font-family: monospace;
            font-size: 14px;
        }
        
        .status-box {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .led {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 10px auto;
            transition: all 0.3s;
        }
        
        .led-on {
            background: #4CAF50;
            box-shadow: 0 0 30px #4CAF50;
            animation: pulse 1.5s infinite;
        }
        
        .led-off {
            background: #f44336;
            box-shadow: 0 0 30px #f44336;
        }
        
        .led-unknown {
            background: #9e9e9e;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-on {
            background: #4CAF50;
        }
        
        .btn-off {
            background: #f44336;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .connection-status {
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .connected {
            background: #d4edda;
            color: #155724;
        }
        
        .disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        
        .connecting {
            background: #fff3cd;
            color: #856404;
        }
        
        .debug {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .test-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .test-btn:hover {
            background: #f57c00;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üöÄ ƒêI·ªÄU KHI·ªÇN ESP32-S3</h1>
        
        <div class="info-box">
            <p><strong>üîó URL:</strong> f70a09e2678a4ee9bd009145291314c2.s1.eu.hivemq.cloud</p>
            <p><strong>üë§ User:</strong> esp32_supermini_control</p>
            <p><strong>üîê Pass:</strong> Esp32@Control2024!</p>
            <p><strong>üì° Port:</strong> 8884 (WebSocket)</p>
        </div>
        
        <!-- N√∫t test k·∫øt n·ªëi -->
        <button class="test-btn" onclick="testConnection()">üîç KI·ªÇM TRA K·∫æT N·ªêI</button>
        
        <div class="status-box">
            <h3>TR·∫†NG TH√ÅI LED</h3>
            <div id="led" class="led led-unknown"></div>
            <p id="statusText" style="font-size: 20px; font-weight: bold;">Ch∆∞a k·∫øt n·ªëi</p>
            <p id="lastUpdate"></p>
        </div>
        
        <div class="btn-group">
            <button id="btnOn" class="btn-on" onclick="sendCommand('ON')" disabled>üî¥ B·∫¨T</button>
            <button id="btnOff" class="btn-off" onclick="sendCommand('OFF')" disabled>‚ö´ T·∫ÆT</button>
        </div>
        
        <div id="connectionStatus" class="connection-status connecting">
            ‚ö° ƒêang k·∫øt n·ªëi HiveMQ Cloud...
        </div>
        
        <div class="debug" id="debug">
            <p>üöÄ ƒêang kh·ªüi t·∫°o...</p>
        </div>
    </div>

    <script>
        const CONFIG = {
            url: "f70a09e2678a4ee9bd009145291314c2.s1.eu.hivemq.cloud",
            port: 8884,
            username: "esp32_supermini_control",
            password: "Esp32@Control2024!"
        };
        
        let client;
        let isConnected = false;
        let reconnectTimer = null;
        
        function debug(msg, isError = false) {
            const debugDiv = document.getElementById('debug');
            const p = document.createElement('p');
            const prefix = isError ? '‚ùå' : 'üïí';
            p.textContent = `${prefix} ${new Date().toLocaleTimeString()} - ${msg}`;
            p.style.color = isError ? '#ff6b6b' : '#00ff00';
            debugDiv.appendChild(p);
            while (debugDiv.children.length > 8) {
                debugDiv.removeChild(debugDiv.firstChild);
            }
            debugDiv.scrollTop = debugDiv.scrollHeight;
            console.log(msg);
        }
        
        function testConnection() {
            debug("üîç ƒêang ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn HiveMQ...");
            
            // Ki·ªÉm tra xem tr√¨nh duy·ªát c√≥ online kh√¥ng
            if (!navigator.onLine) {
                debug("‚ö†Ô∏è Tr√¨nh duy·ªát ƒëang offline!", true);
                return;
            }
            
            debug("üåê Tr√¨nh duy·ªát online");
            debug("üîÑ ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...");
            
            if (client && isConnected) {
                client.disconnect();
            }
            
            setTimeout(() => {
                connectMQTT();
            }, 1000);
        }
        
        function connectMQTT() {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            
            debug(`üîÑ ƒêang k·∫øt n·ªëi ƒë·∫øn ${CONFIG.url}:${CONFIG.port}...`);
            
            try {
                client = new Paho.MQTT.Client(
                    CONFIG.url,
                    CONFIG.port,
                    "web_" + Math.random().toString(36).substring(2, 10)
                );
                
                client.onConnectionLost = (response) => {
                    isConnected = false;
                    debug(`üîå M·∫•t k·∫øt n·ªëi: ${response.errorMessage}`, true);
                    updateConnectionStatus(false);
                    
                    // T·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i sau 5 gi√¢y
                    reconnectTimer = setTimeout(() => {
                        debug("üîÑ ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...");
                        connectMQTT();
                    }, 5000);
                };
                
                client.onMessageArrived = (message) => {
                    const payload = message.payloadString;
                    debug(`üì© Nh·∫≠n: ${payload} t·ª´ ${message.destinationName}`);
                    
                    if (payload === "ON" || payload === "ONLINE") {
                        updateLED("ON");
                    } else if (payload === "OFF") {
                        updateLED("OFF");
                    }
                };
                
                const connectOptions = {
                    onSuccess: () => {
                        isConnected = true;
                        debug("‚úÖ K·∫æT N·ªêI TH√ÄNH C√îNG!");
                        debug("üì• ƒêang subscribe esp32/status...");
                        
                        client.subscribe("esp32/status", {
                            onSuccess: () => {
                                debug("‚úÖ Subscribed esp32/status");
                            },
                            onFailure: (err) => {
                                debug(`‚ùå L·ªói subscribe: ${err.errorMessage}`, true);
                            }
                        });
                        
                        updateConnectionStatus(true);
                        
                        // G·ª≠i y√™u c·∫ßu l·∫•y tr·∫°ng th√°i
                        setTimeout(() => {
                            sendCommand("STATUS");
                        }, 2000);
                        
                        // G·ª≠i STATUS m·ªói 10 gi√¢y ƒë·ªÉ ki·ªÉm tra
                        setInterval(() => {
                            if (isConnected) {
                                sendCommand("STATUS");
                            }
                        }, 10000);
                    },
                    onFailure: (err) => {
                        isConnected = false;
                        debug(`‚ùå L·ªñI K·∫æT N·ªêI: ${err.errorMessage}`, true);
                        debug("üìã KI·ªÇM TRA:");
                        debug("   1. Username: " + CONFIG.username);
                        debug("   2. Password: " + CONFIG.password);
                        debug("   3. URL: " + CONFIG.url);
                        debug("   4. Port: " + CONFIG.port);
                        updateConnectionStatus(false);
                        
                        // Th·ª≠ l·∫°i sau 5 gi√¢y
                        reconnectTimer = setTimeout(() => {
                            debug("üîÑ ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...");
                            connectMQTT();
                        }, 5000);
                    },
                    userName: CONFIG.username,
                    password: CONFIG.password,
                    useSSL: true,
                    keepAliveInterval: 30,
                    cleanSession: true,
                    timeout: 30
                };
                
                client.connect(connectOptions);
                
            } catch (error) {
                debug(`‚ùå L·ªói: ${error.message}`, true);
                updateConnectionStatus(false);
                
                reconnectTimer = setTimeout(() => {
                    connectMQTT();
                }, 5000);
            }
        }
        
        function updateLED(state) {
            const led = document.getElementById('led');
            const text = document.getElementById('statusText');
            const update = document.getElementById('lastUpdate');
            
            led.className = 'led ' + (state === 'ON' ? 'led-on' : 'led-off');
            text.innerHTML = state === 'ON' ? 'üî¥ ƒêANG B·∫¨T' : '‚ö´ ƒêANG T·∫ÆT';
            text.style.color = state === 'ON' ? '#4CAF50' : '#f44336';
            update.innerHTML = `üïê C·∫≠p nh·∫≠t: ${new Date().toLocaleTimeString()}`;
        }
        
        function updateConnectionStatus(connected) {
            const statusDiv = document.getElementById('connectionStatus');
            const btnOn = document.getElementById('btnOn');
            const btnOff = document.getElementById('btnOff');
            
            if (connected) {
                statusDiv.className = 'connection-status connected';
                statusDiv.innerHTML = '‚úÖ ƒê√£ k·∫øt n·ªëi HiveMQ Cloud';
                btnOn.disabled = false;
                btnOff.disabled = false;
            } else {
                statusDiv.className = 'connection-status disconnected';
                statusDiv.innerHTML = '‚ùå M·∫•t k·∫øt n·ªëi. ƒêang th·ª≠ l·∫°i...';
                btnOn.disabled = true;
                btnOff.disabled = true;
            }
        }
        
        function sendCommand(cmd) {
            if (!client || !isConnected) {
                debug("‚ùå Kh√¥ng th·ªÉ g·ª≠i l·ªánh: Ch∆∞a k·∫øt n·ªëi!", true);
                return;
            }
            
            debug(`üì§ G·ª≠i l·ªánh: ${cmd} ƒë·∫øn esp32/control`);
            
            const message = new Paho.MQTT.Message(cmd);
            message.destinationName = "esp32/control";
            message.qos = 1;
            
            try {
                client.send(message);
                debug(`‚úÖ ƒê√£ g·ª≠i ${cmd}`);
                
                // Hi·ªáu ·ª©ng nh·∫•n n√∫t
                const btn = document.getElementById(cmd === 'ON' ? 'btnOn' : 'btnOff');
                btn.style.transform = 'scale(0.95)';
                setTimeout(() => btn.style.transform = '', 200);
            } catch (error) {
                debug(`‚ùå L·ªói g·ª≠i l·ªánh: ${error.message}`, true);
            }
        }
        
        // B·∫Øt ƒë·∫ßu k·∫øt n·ªëi khi load trang
        window.onload = () => {
            debug("üöÄ Trang web ƒë√£ t·∫£i");
            debug(`üë§ Username: ${CONFIG.username}`);
            connectMQTT();
        };
        
        // D·ªçn d·∫πp khi ƒë√≥ng trang
        window.onbeforeunload = () => {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
            }
            if (client && isConnected) {
                client.disconnect();
            }
        };
    </script>
</body>
</html>
